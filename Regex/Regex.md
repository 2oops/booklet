# Regex

   /dzo*/ 匹配前面的子表达式零次或多次,子表达式指*前面的o,o可以有零次或多次,同/dzo{0,}/
​    ep: dz  dzo   dzoooo    aadz   aadzoo

```
/zo+/  匹配+前面的o一次或多次,即表达式中zo至少需出现一次,同/zo{1,}/
ep: zo zoooo aazo 

/does?/ 匹配?前面的s零次或一次,?等价于{0,1}
ep: doe aadoes doesdoe doesss

/{n}/ n为非负整数,匹配确定的n次,/{n,}/和/{n}/有区别,/o{2,}/不能匹配"Bob"中的o，但能匹配"foooood"中的所有o。
注意: 匹配的是前面的子表达式,如/ddd{3}/,匹配的既是最后一个d,一般不能这么写,换之/d{5}/

{n,m} m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次,逗号和两个数之间不能有空格
"o{1,3}"将匹配"fooooood"中的前三个o,"o{0,1}"等价于"o?"
对于字符串"oooo"，"o+?"将匹配单个o，而"o+"将匹配所有o

. 匹配出 \n 之外的任何单个字符,若要匹配 \n 可使用"(.|\n)"

x|y /z|food/能匹配z或food,/(z|f)ood/能匹配zood或food
[xyz]  "[abc]"可以匹配"plain中的a
"[a-z]"可以匹配"a"到"z"范围内的任意小写字母字符.
"[^a-z]"可以匹配非a-z范围内的任意字符.
\b "er\b"可以匹配"never"中的"er"，但不能匹配"verb"中的"er".

\B 匹配非单词边界,与\b相反
\d 匹配一个数字,等价于[0-9]   \D

(.)\1 匹配两个连续的相同字符
\u00A9匹配版权符号(?).
```

```
  大于0的1-6位整数:  /^[1,9]{1}\d{0,5}$/  /^[1,9]{1}[0-9]{0,5}$/
  负整数1-6位  /^-[0-9]*[1-9][0-9]*$/
  非负整数  /^\d+$/
  整数  ^-?\d+$   (未考虑0000)
  非正整数  /^(-\d+|(0+))$/  (其中包括0, 000 ,但01不为非正整数)
  数字字母组成的6位字符串  /^[A-Za-z0-9]{6}$/
  6-8位字母开头数字下划线密码 /^[A-Za-z]\w{5,7}$/
```

ep:
​	/\bhi\b/ 匹配hi这个单词,\b为元字符,代表着单词的开头和结尾,也就是单词的分界处
​      /hi/ 能匹配hi , ahia等
​      /\bhi\b.*\bLucy\b$/ .匹配除了换行符以外的字符,$表示结尾,就是Lucy后面不能再接入字符
​      /0\d{2}-\d{8}/ 表示0开头,然后是两位数字,然后-,再接8位数字未待起始和结尾字符表示匹配中有这段字符即验证通过
​      \s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等
​      \w匹配单词字符,单词字符包括大小写字母,数字及下划线
​      /\ba\w{3}\b$/ 表示a开头后接3个字符
​      有些正则表达式处理工具还有一个处理多行(Mutiline)的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处
​      /\(?0\d{2}[)-]?\d{8}/, 可以匹配(010)88888888, 011)88888888, [)-]? 表示的是)和-二选一
​      /\(0\d{2,3}\)[-]?\d{8}|0\d{2,3}[-]?\d{8}/ 可匹配3和4位区号电话号码,如(0101)88888888
​      匹配IP地址 ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
​      [01]? 表示可以匹配0或1
​      /<a[^>]+>/ 匹配用尖括号括起来的以a开头的字符串
​      /\(a[^\)]+\)/ 匹配用括号括起来的以a开头的字符串

```
  (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp,
  如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)
  如查找I'm singing while you're dancing.时，它会匹配sing和danc

  (?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp
  如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，
  例如在查找reading a book时，它匹配ading

  假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，
  你可以这样查找需要在前面和里面添加逗号的部分：((?<=\d)\d{3})+\b，
  用它对1234567890进行查找时结果是234567890。
  下面这个例子同时使用了这两种断言：(?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)

  负向零宽断言 /\b\w*q(?!u)\w*\b/ 匹配包含后面不是字母u的字母q的单词
  零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp
  例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词
 
  (?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字

  小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)

  当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符
  以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
  有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，
  只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：
  a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）
```