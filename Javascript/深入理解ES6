# 深入理解ES6

1. **改变对象的原型**，ES5的`getPrototypeOf()`方法和ES6添加的`setPrototypeOf()`方法

   ```java
   // 定义两个基对象
   let person = {
     getGreeting() {
       return "hello"
     }
   }
   
   let dog = {
     getGreeting() {
       return "wowo"
     }
   }
   // 以person对象为原型
   let friend = Object.create(person)
   console.log(friend.getGreeting())// hello
   console.log(Object.getPrototypeOf(friend) === person)//true
   // 将原型设置为dog
   Object.setPrototypeOf(friend, dog)
   console.log(friend.getGreeting())//wowo
   console.log(Object.getPrototypeOf(friend) === dog)// true
   ```

2. 使用**super**引用简化原型访问

   ```javascript
   // 先来看一段代码，在ES5中，如果你想重写对象实例的方法，又需要调用与它同名的原型方法
   let person = {
       getGreeting() {
           return "hello"
       }
   }
   let dog = {
       getGreeting() {
           return "woow"
       }
   }
   let friend = {
       getGreeting() {// 这里注意必须要在使用简写方法的对象中使用super引用
           return Object.getPrototypeOf(this).getGreeting.call(this) + ', hi'
           //使用super如下
           // return super.getGreeting() + ', hi'
       }
   }
   // 将原型设置为person
   Object.setPrototypeOf(friend, person)
   console.log(friend.getGreeting())// hello, hi
   console.log(Object.getPrototypeOf(friend) === person)// true
   // 其实以上friend对象中Object.getPrototypeOf(this)就相当于super
   
   // 在多重继承中，super引用非常有用，并且，使用Object.setPrototypeOf()会出现问题，
   //因为setPrototypeOf()中的this问题最终会导致栈溢出报错
   // 如下使用super
   let person = {
       getGreeting() {
           return 'hello'
       }
   }
   let friend = {
       getGreeting() {
           return super.getGreeting() + ',hi'
       }
   }
   Object.setPrototypeOf(friend, person)
   
   let relative = Object.create(friend)
   console.log(person.getGreeting())// 'hello'
   console.log(friend.getGreeting())// 'hello,hi'
   console.log(relative.getGreeting())// 'hello,hi'
   ```

3. ES6正式定义了方法

   ```javascript
   let person = {
       // getGreeting()是方法
       getGreeting() {
           return 'hello'
       }
   }
   // 不是方法
   function share() {
       return 'hi'
   }
   // 这个示例中定义了一个person对象，该对象有一个getGreeting()方法，由于直接把函数赋值给了person对象
   // 因此getGreeting()方法的[[HomeObject]]属性值为person，而share函数并未明确定义该属性，虽然这是
   // 个小差别，但是在super引用中这很重要，这就是为什么在2中要求super引用要在对象简写方法中使用。
   ```

4. ES6扩展对象功能性中还扩展了`assign()`以及`Object.is()`(该方法对所有值进行严格等价判断，比三等号操作符更安全)

   ```javascript
   Object.is(5, '5')// false
   Object.is(NaN, NaN)// true
   NaN === NaN // false
   +0 === -0 // true
   Object.is(+0, -0) // false
   
   // assign()
   let receiver = {}
   Object.assign(receiver,
       {
       name: 'xiaoa',
       type: 'js'
   },{
       type: 'string'// 排位靠后的源对象会覆盖靠前的
   })
   console.log(receiver.type) // "string"
   ```

5. ES6中的类

   1. 其实在ES5中已经存在近类结构，思路是这样的：简单来说就是创建一个自定义类型，首先创建一个构造函数，然后定义另一个方法并赋值给构造函数的原型。

      ```javascript
      function PersonType(name) {
      	this.name = name // 创造构造函数
      }
      PersonType.prototype.sayName = function() { // 给函数原型定义一个方法
          console.log(this.name)
      }
      let person = new PersonType("Nical")
      person.sayName() // "Nical"
      person instanceof PersonType // true
      person instanceof Object // true
      ```

      `PersonType`的原型在添加了sayName()方法后，`PersonType`对象的所有实例都将共享这个方法，然后使用new操作符创建了`person`实例。这里person对象是PersonType的实例，由于使用了**原型继承**，所以person也是Objec的实例

   2. 而基本类是这样声明的，与1中的原型继承有相似之处

      ```javascript
      class PersonClass {
          constructor(name) { // 创建构造函数
              this.name = name 
          }
          sayName() { // 定义一个方法
              console.log(this.name)
          }
      }
      let person = new PersonClass("Nical")
      person.sayName() // "Nical"
      person instanceof PersonClass // true
      person instanceof Object // true
      typeof PersonClass // "function"
      typeof PersonClass.prototype.sayName // "function"
      ```

      `PersonClass`中除`constructor`外没有其他保留的方法名，因此可以方便的添加方法。与近类结构不同的是，类属性不可被赋予新值，`PersonClass.prototype`是一个只可读的类属性。

      使用类语法时应注意：

      1）类声明中的所有代码将自动运行在严格模式下，且无法脱离严格模式；

      2）在类中，所有方法都是不可枚举的；

      3）每个类都有[[construct]]内部方法，new关键字只调用该构造函数且只能用new调用它；

      4）类声明不能像函数声明那样被提升，在真正执行声明语句前，它们会一直存在于临时死区中；

      5）类中不能修改类名，因为类名在类中为常量，而在外部是可以修改的。

   3. 



