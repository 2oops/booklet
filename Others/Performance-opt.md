# Performance-opt

1. Vue 应用运行时以及加载时的一些性能优化措施，下面做一个回顾和概括：
   - Vue 应用运行时性能优化措施
   - 引入生产环境的 Vue 文件
   - 使用单文件组件预编译模板
   - 提取组件的 CSS 到单独到文件
   - 利用Object.freeze()提升性能
   - 扁平化 Store 数据结构
   - 合理使用持久化 Store 数据
   - 组件懒加载

2. Vue 应用加载性能优化措施
   - 服务端渲染 / 预渲染
   - 组件懒加载

3. 性能优化的核心是减少request round的数量，就是你的页面需要多少个请求回路才能展示首屏

4. **首页白屏优化实践**：[参考](https://juejin.im/post/5d7468db5188253264365017)

   - **处理方法1：SSR**
     优点：因为不需要动态渲染数据，所以顺便解决了SEO的问题；
     缺点：不利于维护，对前端工程师有技术要求，增加了服务器的压力
   - **处理方法2：预渲染**
     使用prerender-spa-plugin做预渲染，这样可以在浏览器上进行渲染，而不需要讲vue或react代码部署到服务器上
     缺点：动态数据无法展示，不同用户看到的是同样的页面；
     路由很多时，代码构建时间长；
     用户容易误操作，预渲染时js还没有预加载，因此展示出来的内容没有js交互逻辑；
     预加载中的动态数据加载不出来无法编译
   - **处理方法3：骨架屏**
     原理与预加载类似，都是利用了Puppeteer爬取页面的功能，其为chrome出的一个headlessChromenode库，提供了api可以抓取spa并生成预渲染的内容，和预加载的区别在于它是生成内容后利用算法将生成的内容进行替换，从而生成骨架页面。
     wepback插件 => page-skeleton-webpack-plugin

5. 性能优化

  1. 使用`Chrome`浏览器开发者工具自带的`Audits`，可以对网站做一个性能报告评估，此报告会给出出各个指标（包括性能、`SEO`、体验等）的评估结果和优化建议，开发者从而可以对各项指标进行再优化。如下图

     ![1](C:\Users\Administrator\Desktop\1.png)

     ![2](C:\Users\Administrator\Desktop\2.png)

     ![3](C:\Users\Administrator\Desktop\3.png)

  2. 使用`Chrome`浏览器提供的`Performance`工具可以让我们详细的看到页面加载时哪个阶段在处理什么事情，哪个阶段耗时最多，可以进一步了解性能瓶颈。

  3. 针对JS的优化，我们都知道JS需要引擎才能运行起来，谷歌的`V8引擎`下又引入了`TurboFan`编译器，为的就是在某些情况下，将代码编译成执行效率更高的`机器码`，但这个编译器不是必须的，它只是为了提高性能。所以总的来说JS偏向于解释型语言而不是编译型语言。

     JS首先会被解析成AST抽象语法树，代码越多，解析也就越慢，所以一般建议压缩代码。另一种方式是预解析，会作用于未执行的函数，以此减少解析时间。

     ![img](https://user-gold-cdn.xitu.io/2018/12/3/167736409eebe688?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

     解析成AST后，`Ignition`负责转成`Bytecode`，这个过程中可能还会使用到`TurboFan`编译，然后再对编译得到的机器码进行优化。这里有个疑问是说，什么时候代码会编译成机器码，联想到`Typescript`的普及，我们可以知道的一点是当固定了类型后，`V8引擎`就会认为该段代码可以编译为机器码。

     从浏览器底层优化来说，只要我们按一定的规则书写代码，引擎底层就能够帮助我们自动优化代码。另外，编译器还有一个`Lazy-Compile`的操作，当函数没有执行的时候会对函数预解析，直到代码执行时才会被解析编译。可以使用将函数套上括号的方式使函数不被预解析。

  4. 所以这里得出第四点，减少代码文件的大小和减少书写嵌套函数都可以减少编译时间，从而做到一个优化。

***

**内存泄漏总结：**

1. 尽量避免全局变量的使用
   - window下的
   - this指向的全局对象调用
2. 及时清理计时器和回调函数
   - setTimeout/setInterval

3. 避免脱离DOM的引用

   - 如DOM树中节点虽然删除了，但是还在其他地方或函数中引用，会造成无法被GC回收

4. echarts视图不断更新时，及时清理了setInterval时，也可能导致内存泄漏

   解决方法：

   ```javascript
   myChart.clear();
   myChart.setOption(option);
   ```

   使用计时器时更新series里面的数据而不是全部`setOption(option)`

5. 善用闭包

