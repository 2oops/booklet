# React

[TOC]

---

#### React&Vue

1. `MVVM&MVC`
1. 关于这两者我们要知道的事情是，两者均不是`MVVM`框架，只是借鉴了其思想。`MVVM`和`MVC`之间的区别在于，`MVC`是使用控制器去更新模型，然后从模型中获取到数据渲染视图。当用户有输入时，会通过控制器去更新模型，并通知视图进行更新。从中我们可以看出，`MVC`中控制器的责任太重了，如果项目变得复杂，那么代码会变得很臃肿，不利于维护。
   2. 在`MVVM`中引入了`viewmodel`的概念，其只关心数据和业务的处理，而不用在意`view`如何处理数据。这样`view`和`model`都独立出来，任何一方改变都不一定会改变另一方，对于可复用的逻辑可以放在一个`viewModel`中，让多个`view`复用该`ViewModel`。
   3. 对于`Vue`框架来说，`ViewModel`就是组件的实例。`View`就是模板，`Model`倾向于对数据的处理。其中还加入了隐式的`binder`，它是`Vue`通过解析模板中的插值和指令对`View`和`ViewModel`的绑定。
   4. 通过`ViewModel`将视图中的状态和用户的行为分离出一个抽象，才是`MVVM`的精髓。
   
2. `Virtual DOM`

   1. 首先我们要明白一点，操作`JS`对象比操作`DOM`会快很多；
   2. 所以我们可以使用`JS`对象来模拟出虚拟的`DOM`，但这只是第一步，真正体现差异的是如何判断两个`JS`对象的最小差异并且实现局部更新。
   3. `DOM`是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么时间复杂度是很大的。而`React`团队优化了算法，将时间复杂度降到了`O(n)`。
   4. `React`和`Vue`中用到的`key`这个属性，就是为了给每个节点打标志的，用于判断是否为同一个节点，判断差异的算法因此受益（深度优先遍历）。
   5. 虚拟`DOM`提高了性能是其一优势，但是，其最大的优势在于，将`Virtual DOM`作为一个兼容层，还可以对接`非WEB`系统，实现跨端开发。除此之外，通过虚拟`DOM`还可以渲染到其他平台，如实现`SSR`，同构渲染等，而且还可以实现组件的高度抽象化。
3. 前端路由原理

   1. 包括两种实现方式：`Hash`模式和`History`模式；
   2. 其本质就是**监听URL的变化**，然后匹配路由规则，实现局部刷新页面。
   3. `Hash`模式：`www.test.com/#/`就是该模式，服务器接收到的请求永远是#号前的地址。#后的哈希值发生变化时，可以通过`hashchange`事件监听到URL的变化。其优点是相对简单，而且兼容性好。
   4. `Histroy`模式：由`H5`推出，主要使用`history.pushState`和`history.replaceState`改变URL，此模式同样不会引起页面的刷新，只会更新浏览器的浏览记录。如使用`popState`可以后退。
   5. 两种方式的对比：
      - `Hash`只可以改变#号后面的内容，`History`可以通过API设置任何同源的URL
      - `Hash`只能更改哈希值，而`History`可以通过API添加任意类型的数据到历史记录中
      - `Hash`无需后端配置，而`History`模式在用户手动输入地址或刷新页面的时候会发起URL请求，且后端需配置匹配不到静态资源时的`index.html`
4. `React&Vue`之间的区别

   - `Vue`支持双向绑定，相对来说更方便一点，但本质上两者是一样的。

   - 改变数据状态的方式上，`React`需要使用`setState`来改变状态，而`vue`底层使用了依赖追踪，更新渲染更优。

   - `React`的`Jsx`还是有一定的上手难度，还可以直接编写`render`函数就能在浏览器中运行。
   - 生态

#### 基础

1. `React`的设计思想

   

   - 视图完全由数据驱动
   - 一切都是组件
   - props是组件通信的基本方式

2. 组件设计的原则

   - 保持接口小，尽可能的少props
   - state尽量往外层提取
   - 按数据边界划分组件

   最佳实践：

   - 避免renderXXX函数盛行
   - `propTyps`校验
   - 给回调函数类型统一加前缀`on` 或者`handle`
   - 每个组件源代码拆分

3. 

#### 进阶

