# Advanced2

***

**Golang并发**

1. Go 语言通过编译器运行时（runtime），从语言上支持了并发的特性，由goroutine特性完成，**goroutine由语言运行时调度完成，而线程是由操作系统调度完成**，此外，Go 语言还提供 **channel** 在多个 goroutine 间进行通信。goroutine和channel是golang秉承并发模式的重要实现基础。

2. go从语言层面就支持并发，同时实现了自动垃圾回收机制

   进程和线程：

   进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位

   线程是进程的一个执行实体，是CPU调度和分派的基本单位

   并发和并行：

   多线程在单核CPU上运行，称为并发（主要通过切换时间片来实现“同时”运行）

   多线程程序在多核CPU上运行，称为并行

   协程和线程：

   协程：独立的栈空间，共享堆空间，调度由用户自己控制

   线程：一个线程上可以跑多个协程，协程是轻量级的线程

   **goroutine:**

   说到底就是线程，但是比线程小，十几个 goroutine 可能体现在底层就是五六个线程，而且Go语言内部也实现了 goroutine 之间的内存共享。

   **channel**（联想Unix管道）

   是go在语言级别提供的goroutine的通信方式，channel是进程内的通信方式，因此channel传递对象的方式和函数的传参方式基本是一致的，（可以传递指针等）

   如果需要跨进程通信，可以使用分布式系统的方法来解决，如使用HTTP/Socket，go对网络方面也有非常完善的支持

   并发程序的优点：

   - 客观表现问题模型
   - 充分利用CPU多核优势
   - 充分利用CPU与硬件固有的异步特性

3. goroutine创建

   - 通过普通函数创建
   - 通过匿名函数创建

   所有goroutine在main函数结束时才会一同结束

   Goroutine类似于线程概念，但是没有线程细致，细致程度取决于go程序的goroutine的调度器实现和运行环境

   终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数。

4. 并发通信

   两种最常见的**并发通信模型：**共享数据和信息

   go提供另一种通信模型：即以消息机制而非共享内存作为通信方式

   **消息机制认为每个共享单元都是自包含的、独立的个体，他们有自己的变量，但在不同并发单元中这些变量不共享，每个单元的输入和输出只有一种，即是消息。类似于进程，不同进程间各自负责自己的任务就OK，不共享内存。**

   共享数据是指多个并发单元保持对同一个数据的引用，实现对该数据的共享，共享的数据可能有多种格式，如内存数据块、网络数据、磁盘文件等，最常用的是共享内存。

   并发编程难点在于协调调度，协调就要通过交流，因此从某种程度上来说，并发单元间的通信是最大的问题

5. 并发中的资源竞争

   有并发，就有资源竞争。比如同时对一个资源进行读写，这时候就会产生资源竞争（对于同一个资源的读写必须是原子化的，也就是说，同一时间只能允许有一个goroutine对共享资源进行读写操作。）

   `go build -race`运行生成的可执行文件，可以看到打印出的检测信息，可以检测共享资源竞争的问题

   go提供了传统的同步groutine机制，就是对共享资源加锁。

   `atomic 和 sync`原子函数和互斥锁

   

