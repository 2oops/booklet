# Advanced2

***

**Golang并发**

1. Go 语言通过编译器运行时（runtime），从语言上支持了并发的特性，由goroutine特性完成，**goroutine由语言运行时调度完成，而线程是由操作系统调度完成**，此外，Go 语言还提供 **channel** 在多个 goroutine 间进行通信。goroutine和channel是golang秉承并发模式的重要实现基础。

2. go从语言层面就支持并发，同时实现了自动垃圾回收机制

   进程和线程：

   进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位

   线程是进程的一个执行实体，是CPU调度和分派的基本单位

   并发和并行：

   多线程在单核CPU上运行，称为并发（主要通过切换时间片来实现“同时”运行）

   多线程程序在多核CPU上运行，称为并行

   协程和线程：

   协程：独立的栈空间，共享堆空间，调度由用户自己控制

   线程：一个线程上可以跑多个协程，协程是轻量级的线程

   **goroutine:**

   说到底就是线程，但是比线程小，十几个 goroutine 可能体现在底层就是五六个线程，而且Go语言内部也实现了 goroutine 之间的内存共享。

   **channel**（联想Unix管道）

   是go在语言级别提供的goroutine的通信方式，channel是进程内的通信方式，因此channel传递对象的方式和函数的传参方式基本是一致的，（可以传递指针等）

   如果需要跨进程通信，可以使用分布式系统的方法来解决，如使用HTTP/Socket，go对网络方面也有非常完善的支持

   并发程序的优点：

   - 客观表现问题模型
   - 充分利用CPU多核优势
   - 充分利用CPU与硬件固有的异步特性

3. goroutine创建

   - 通过普通函数创建
   - 通过匿名函数创建

   所有goroutine在main函数结束时才会一同结束

   Goroutine类似于线程概念，但是没有线程细致，细致程度取决于go程序的goroutine的调度器实现和运行环境

   终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数。

4. 并发通信

   两种最常见的**并发通信模型：**共享数据和信息

   go提供另一种通信模型：即以消息机制而非共享内存作为通信方式

   **消息机制认为每个共享单元都是自包含的、独立的个体，他们有自己的变量，但在不同并发单元中这些变量不共享，每个单元的输入和输出只有一种，即是消息。类似于进程，不同进程间各自负责自己的任务就OK，不共享内存。**

   共享数据是指多个并发单元保持对同一个数据的引用，实现对该数据的共享，共享的数据可能有多种格式，如内存数据块、网络数据、磁盘文件等，最常用的是共享内存。

   并发编程难点在于协调调度，协调就要通过交流，因此从某种程度上来说，并发单元间的通信是最大的问题

5. 并发中的资源竞争

   有并发，就有资源竞争。比如同时对一个资源进行读写，这时候就会产生资源竞争（对于同一个资源的读写必须是原子化的，也就是说，同一时间只能允许有一个goroutine对共享资源进行读写操作。）

   `go build -race`运行生成的可执行文件，可以看到打印出的检测信息，可以检测共享资源竞争的问题

   go提供了传统的同步groutine机制，就是对共享资源加锁。

   `atomic 和 sync`原子函数和互斥锁

6. 调整运行时的并发性能

   `runtime.GOMAXPROCS(runtime.NumCPU())`

   Go 在GOMAXPROCS数量和任务数量相等时，可以做到并行执行，大多数情况下都是并发执行

7. goroutine和coroutine（Lua）的区别

   Coroutine运行机制属于协作式任务处理，需要程序主动交出CPU的使用权，而这在开发者未在程序完成时设置交出使用权的时候就容易出现死机或失去响应。

   goroutine属于抢占式任务处理，执行权交由操作系统，当某个任务处理时间过长，长时间占用大量CPU时，操作系统有权终止该任务。

8. **channel**（FIFO队列）

   go提倡用通信的方法代替共享内存，当一个资源需要在多个goroutine之间共享时，通道在goroutine之间架起一条管道，并确保数据能同步交换，声明通道（引用类型make）时，需要指定将要被共享的数据的类型。

   在任何时候，只能有一个goroutine访问通道进行发送和获取数据，goroutine间通过通道就可以通信。

   ```go
   ch := make(chan interface{})
   ch <- 0 // 发送0到接口通道
   ch <- "hello" // 发送字符串到接口通道
   data := <-ch // 执行到这里会阻塞，直到接收到数据并赋给data为止
   data, ok := <-ch // 非阻塞接收数据
   <- ch // 执行时发生阻塞，直到接收到数据，但会忽略接收的数据
   
   func main() {
     ch := make(ch int)
    // 开启一个匿名函数并发
     go func() {
       fmt.Println("start")
       ch <- 0
       fm.Println("end")
     }()
     fmt.Println("wait goroutine") // 匿名函数结束时通知另一个goroutine
     <- ch // 等待匿名goroutine
     fmt.Println("all done")
   }
   // wait goroutine
   // start
   // end
   // all done
   ```

   **使用通道接收数据**

   - 通道的收发操作需要在不同的两个goroutine中进行

     如果发送方一直发送，而没有接收方处理，会造成阻塞，因此通道的接收方需要在另一个goroutine中进行

   - 接收方将持续阻塞直到发送方发送数据

     如果接收数据时，发送方一直没有发送数据，接收方也会发生阻塞，直到发送方发送数据为止

   - 每次只接收一个数据

     阻塞接收数据

     非阻塞接收数据

     接收任意数据，但忽略接收的数据

     循环接收// 通道ch是可以进行遍历的

   